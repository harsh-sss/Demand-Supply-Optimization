# -*- coding: utf-8 -*-
"""Main.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1v535SDn38tPPjgNI9H_ch1bBm8Oku83-
"""

# Install Prophet if not already installed
!pip install prophet

import pandas as pd
from prophet import Prophet
import matplotlib.pyplot as plt
from google.colab import files

# Upload the file from your local machine
uploaded = files.upload()

# Assuming the uploaded file is named "realistic_supply_demand_inventory.csv"
df = pd.read_csv(next(iter(uploaded)))  # Reads the first uploaded file

# Get unique product IDs
product_ids = df['Product ID'].unique()

# Dictionary to store forecasts for each product
forecasts = {}

# Loop through each product and forecast
for product_id in product_ids:
    # Filter data for the current product
    df_product = df[df['Product ID'] == product_id]

    # Prepare data for Prophet
    df_prophet = df_product[['Date', 'Sales Quantity', 'Promotion', 'Seasonality Factor', 'Holiday Effect']]
    df_prophet.rename(columns={'Date': 'ds', 'Sales Quantity': 'y'}, inplace=True)

    # Initialize Prophet model with seasonality and regressors
    model = Prophet(yearly_seasonality=True, weekly_seasonality=True)
    model.add_seasonality(name='monthly', period=30.5, fourier_order=5)
    model.add_regressor('Promotion')
    model.add_regressor('Seasonality Factor')
    model.add_regressor('Holiday Effect')

    # Fit the model
    model.fit(df_prophet)

    # Create a future DataFrame for 365 days
    future = model.make_future_dataframe(periods=365)
    future['Promotion'] = 0
    future['Seasonality Factor'] = 1
    future['Holiday Effect'] = 0

    # Generate forecast
    forecast = model.predict(future)
    forecasts[product_id] = forecast  # Store forecast for each product

    # Plot the forecast
    fig = model.plot(forecast)
    plt.title(f"Sales Forecast for {product_id}")
    plt.xlabel("Date")
    plt.ylabel("Sales Quantity")
    plt.show()

    # Optional: Plot forecast components for each product
    fig_components = model.plot_components(forecast)
    plt.show()

# If you want to save all forecasts into a single DataFrame
all_forecasts = pd.concat(
    [forecast.assign(Product_ID=product_id) for product_id, forecast in forecasts.items()],
    ignore_index=True
)

# Save all forecasts to CSV for further analysis
all_forecasts.to_csv('/content/all_product_forecasts.csv', index=False)
print("All product forecasts saved as 'all_product_forecasts.csv'.")

# Download the forecast file if needed
files.download('/content/all_product_forecasts.csv')

import numpy as np

# Define lead time in days (example: 7 days)
lead_time = 7

# Dictionary to store reorder points for each product
reorder_points = {}

for product_id, forecast in forecasts.items():
    # Calculate forecasted demand over lead time
    forecasted_demand_lead_time = forecast['yhat'].iloc[:lead_time].sum()

    # Calculate safety stock (1.5 * std deviation over lead time as an example)
    safety_stock = 1.5 * forecast['yhat'].iloc[:lead_time].std()

    # Calculate reorder point
    reorder_point = forecasted_demand_lead_time + safety_stock

    # Store reorder point in the dictionary
    reorder_points[product_id] = {
        'Forecasted Demand': forecasted_demand_lead_time,
        'Safety Stock': safety_stock,
        'Reorder Point': reorder_point
    }

# Convert the reorder points dictionary to a DataFrame for easy viewing
df_reorder_points = pd.DataFrame(reorder_points).T
df_reorder_points.reset_index(inplace=True)
df_reorder_points.rename(columns={'index': 'Product_ID'}, inplace=True)

# Display the reorder points DataFrame
print("Dynamic Reorder Points for each product:")
print(df_reorder_points)

# Save the reorder points to a CSV file for further use
df_reorder_points.to_csv('/content/dynamic_reorder_points.csv', index=False)
print("Dynamic reorder points saved as 'dynamic_reorder_points.csv'.")

# Assuming df contains historical sales data with columns 'Product ID', 'Date', and 'Sales Quantity'

# Set lead time (e.g., 7 days)
lead_time = 7

# Calculate average daily demand for each product
avg_daily_demand = df.groupby('Product ID')['Sales Quantity'].mean()

# Calculate safety stock based on historical standard deviation (you can adjust the multiplier if needed)
safety_stock_static = df.groupby('Product ID')['Sales Quantity'].std() * 1.5

# Calculate the static reorder point for each product
static_reorder_points = (avg_daily_demand * lead_time) + safety_stock_static

# Create a DataFrame to compare static and dynamic reorder points
reorder_point_comparison = pd.DataFrame({
    'Product ID': avg_daily_demand.index,
    'Static Reorder Point': static_reorder_points.values,
    'Dynamic Reorder Point': df_reorder_points['Reorder Point'].values  # from dynamic reorder points calculated earlier
})

# Display the comparison
print("Static vs. Dynamic Reorder Points for each product:")
print(reorder_point_comparison)

import time
from datetime import datetime

def calculate_reorder_points():
    # Place your reorder point calculation logic here.
    # For example:
    print(f"Calculating reorder points at {datetime.now()}")
    # Your reorder point code goes here.
    # Example:
    # forecast, reorder_point = your_reorder_point_calculation()
    # print(f"Forecast: {forecast}, Reorder Point: {reorder_point}")

# Run the calculation every 24 hours
try:
    while True:
        calculate_reorder_points()
        # Wait for 24 hours (24*60*60 seconds)
        time.sleep(24 * 60 * 60)
except KeyboardInterrupt:
    print("Stopped the scheduling loop.")

# Save the trained Prophet model to a file
import joblib

joblib.dump(model, '/content/prophet_model.pkl')

import smtplib
from datetime import datetime
from email.mime.text import MIMEText
import pandas as pd
import time

# Load data files
df = pd.read_csv('/content/realistic_supply_demand_inventory.csv')  # Inventory data
df_reorder_points = pd.read_csv('/content/dynamic_reorder_points.csv')  # Reorder points data

# Define email details for sending alerts
def send_email_alert(subject, message, recipient_email="harshvardhan.jha@somaiya.edu"):
    smtp_server = "smtp.gmail.com"  # SMTP server
    smtp_port = 587
    sender_email = "harshsssjha2308@gmail.com"
    sender_password = "hjnq acsa myfp ewre"  # Use an app-specific password if using Gmail

    # Compose email
    msg = MIMEText(message)
    msg['Subject'] = subject
    msg['From'] = sender_email
    msg['To'] = recipient_email

    try:
        # Connect to the SMTP server and send the email
        server = smtplib.SMTP(smtp_server, smtp_port)
        server.starttls()
        server.login(sender_email, sender_password)
        server.sendmail(sender_email, recipient_email, msg.as_string())
        server.quit()
        print("Alert sent successfully!")
    except Exception as e:
        print("Error sending alert:", e)

# Define the function to check inventory and send alerts
def check_inventory_and_send_alerts(df_inventory, reorder_points_df):
    for product_id in reorder_points_df['Product_ID']:
        product_inventory = df_inventory[df_inventory['Product ID'] == product_id]

        # Ensure the product exists in the inventory dataframe
        if product_inventory.empty:
            print(f"Product {product_id} not found in inventory data.")
            continue

        current_stock = product_inventory['Stock Level'].values[0]
        reorder_point = reorder_points_df[reorder_points_df['Product_ID'] == product_id]['Reorder Point'].values[0]

        # Check if the current stock is below or equal to the reorder point
        if current_stock <= reorder_point:
            # Alert message
            message = (f"ALERT: Stock level for product {product_id} is at {current_stock}, "
                       f"below the reorder point of {reorder_point}. Consider reordering soon.")
            send_email_alert(f"Reorder Alert for {product_id}", message)
            print(message)

# Automate inventory check every 24 hours
try:
    while True:
        print(f"Running inventory check at {datetime.now()}")
        check_inventory_and_send_alerts(df, df_reorder_points)
        time.sleep(86400)  # Check every 24 hours (86400 seconds)
except KeyboardInterrupt:
    print("Stopped real-time alert monitoring.")

import pandas as pd

# Load inventory data
df_inventory = pd.read_csv('/content/realistic_supply_demand_inventory.csv')

# Load dynamic reorder points data
df_reorder_points = pd.read_csv('/content/dynamic_reorder_points.csv')

# Set lead time (e.g., 7 days)
lead_time = 7

# Calculate average daily demand and standard deviation for each product
avg_daily_demand = df_inventory.groupby('Product ID')['Sales Quantity'].mean()
safety_stock_static = df_inventory.groupby('Product ID')['Sales Quantity'].std() * 1.5

# Calculate the static reorder point for each product
static_reorder_points = (avg_daily_demand * lead_time) + safety_stock_static

# Convert to DataFrame
df_static_reorder_points = static_reorder_points.reset_index()
df_static_reorder_points.columns = ['Product ID', 'Static Reorder Point']

# Merge static and dynamic reorder points for comparison, using 'Product ID' as the merge key
comparison_df = pd.merge(df_static_reorder_points, df_reorder_points, left_on='Product ID', right_on='Product_ID', how='inner')

# Ensure the correct columns are selected for Static and Dynamic reorder points
comparison_df = comparison_df[['Product ID', 'Static Reorder Point', 'Reorder Point']]
comparison_df.columns = ['Product ID', 'Static Reorder Point', 'Dynamic Reorder Point']  # Rename columns for clarity

# Display comparison to verify columns
comparison_df.head()

import matplotlib.pyplot as plt

comparison_df.plot(x='Product ID', y=['Static Reorder Point', 'Dynamic Reorder Point'], kind='bar', figsize=(12, 6))
plt.title("Static vs Dynamic Reorder Points per Product")
plt.xlabel("Product ID")
plt.ylabel("Reorder Point")
plt.show()

holding_cost_per_unit = 1  # Example cost per unit held

# Calculate average holding cost for each system
avg_static_inventory = avg_daily_demand * lead_time + safety_stock_static
avg_dynamic_inventory = avg_daily_demand * lead_time + df_reorder_points['Reorder Point'].values

static_holding_cost = avg_static_inventory.sum() * holding_cost_per_unit
dynamic_holding_cost = avg_dynamic_inventory.sum() * holding_cost_per_unit

print("Static System Holding Cost:", static_holding_cost)
print("Dynamic System Holding Cost:", dynamic_holding_cost)